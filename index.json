[{"categories":["Android"],"content":"안드로이드에서 파일에 접근하기 위해선 권한을 주어야 한다. 초창기에는 그냥 매니페스트에 스토리지 접근 권한을 넣어주면 바로 접근이 가능했으나 어느새 부터인가 권한 화인창을 띄우야 하도록 변경이 되었다. 취미로 이런저런 앱을 만들면서 했던 작업들을 남겨 보았다. ","date":"2022-10-31","objectID":"/2022/10/2022-10-31-%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%A0%91%EA%B7%BC/:0:0","tags":["Android","Storage","Permission"],"title":"안드로이드 스토리지 접근","uri":"/2022/10/2022-10-31-%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%A0%91%EA%B7%BC/"},{"categories":["Android"],"content":"Lollipop \u003c!-- AndroidMenifest.xml --\u003e \u003cmanifest ...\u003e \u003cuses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/\u003e \u003cuses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/\u003e \u003capplication ...\u003e // MainActivity.kt override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) startActivity() } fun showToast() { File(\"${getSdPath()}/test.txt\").inputStream().use { Toast.makeText(this, String(it.readBytes()), Toast.LENGTH_LONG).show() } } fun writeFile() { File(\"${getSdPath()}/test.txt\").outputStream().use { it.write(\"test ver: ${getAndroidVersion()}\".toByteArray()) } } fun getSdPath() = if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) { Environment.getExternalStorageDirectory().absolutePath } else { Environment.MEDIA_UNMOUNTED } fun startActivity() { writeFile() showToast() } 안드로이드 롤리팝 실행 화면\r롤리팝에서는 권한만 넣어준다면 잘 동작하는 것을 볼 수 있다. ","date":"2022-10-31","objectID":"/2022/10/2022-10-31-%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%A0%91%EA%B7%BC/:1:0","tags":["Android","Storage","Permission"],"title":"안드로이드 스토리지 접근","uri":"/2022/10/2022-10-31-%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%A0%91%EA%B7%BC/"},{"categories":["Android"],"content":"Marshmallow 버전만 업그레이드 하였는데 아래와 같이 EACCES 에러가 발생하였다 E/AndroidRuntime: FATAL EXCEPTION: main Process: d3v.dev.storagetest, PID: 4388 java.lang.RuntimeException: Unable to start activity ComponentInfo{d3v.dev.storagetest/d3v.dev.storagetest.MainActivity}: java.io.FileNotFoundException: /storage/emulated/0/test.txt: open failed: EACCES (Permission denied) at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2416) at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2476) 이 문서에 따르면 안드로이드 M 이후부터는 런타임 권한을 이용하여 사용자의 승인을 받아야 한다고 되어있다. 아래와 같이 수정하였다 // MainActivity.kt companion object { const val requestRuntimePermission = 1 } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) if (requestRuntimePermission()) { startActivity() } } fun requestRuntimePermission(): Boolean { if (Build.VERSION.SDK_INT \u003e= Build.VERSION_CODES.M) { if ( checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED || checkSelfPermission(Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED ) { requestPermissions(arrayOf( Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.READ_EXTERNAL_STORAGE ), requestRuntimePermission) return false } } return true } override fun onRequestPermissionsResult( requestCode: Int, permissions: Array\u003cout String\u003e, grantResults: IntArray ) { when(requestCode) { requestRuntimePermission -\u003e { if (grantResults.any { it != 0 }) { // 획득에 실패한 권한이 있으면 메세지 출력 후 종료 Toast.makeText(this, \"권한 획득 실패\", Toast.LENGTH_LONG).show() finish() } else { Toast.makeText(this, \"권한 획득 성공\", Toast.LENGTH_LONG).show() startActivity() } } else -\u003e {} } super.onRequestPermissionsResult(requestCode, permissions, grantResults) } 런타임 권한 요청 화면\r안드로이드 마쉬맬로우 실행 화면\r","date":"2022-10-31","objectID":"/2022/10/2022-10-31-%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%A0%91%EA%B7%BC/:2:0","tags":["Android","Storage","Permission"],"title":"안드로이드 스토리지 접근","uri":"/2022/10/2022-10-31-%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%A0%91%EA%B7%BC/"},{"categories":["Android"],"content":"안드로이드 10 또 다시 에러와 만났다. E/AndroidRuntime: FATAL EXCEPTION: main Process: d3v.dev.storagetest, PID: 5350 java.lang.RuntimeException: Failure delivering result ResultInfo{who=@android:requestPermissions:, request=1, result=-1, data=Intent { act=android.content.pm.action.REQUEST_PERMISSIONS (has extras) }} to activity {d3v.dev.storagetest/d3v.dev.storagetest.MainActivity}: java.io.FileNotFoundException: /storage/emulated/0/test.txt: open failed: EACCES (Permission denied) \u003c!-- AndroidManifest.xml --\u003e ... \u003capplication ... android:requestLegacyExternalStorage=\"true\" ...\u003e ...... android:requestLegacyExternalStorage=\"true\" 를 추가해 주면 다시 접근이 가능해진다. 안드로이드 10 실행화면\r","date":"2022-10-31","objectID":"/2022/10/2022-10-31-%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%A0%91%EA%B7%BC/:3:0","tags":["Android","Storage","Permission"],"title":"안드로이드 스토리지 접근","uri":"/2022/10/2022-10-31-%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%A0%91%EA%B7%BC/"},{"categories":["Android"],"content":"안드로이드 11 또 다시 에러가 발생하였다 안드로이드 11 부터는 저장소에 직접적으로 접근하려면 MANAGE_EXTERNAL_STORAGE 권한이 필요하다고 한다. 참고 자료 따라서 아래와 같이 수정을 진행하였다 \u003c!-- AndroidMenifest.xml --\u003e \u003cmanifest ...\u003e \u003cuses-permission android:name=\"android.permission.MANAGE_EXTERNAL_STORAGE\" tools:ignore=\"ScopedStorage\" /\u003e \u003capplication ...\u003e // MainActivity.kt fun requestRuntimePermission(): Boolean { if (Build.VERSION.SDK_INT \u003e= Build.VERSION_CODES.R) { if (!Environment.isExternalStorageManager()) { val actionManageAppAllFilesAccessPermission = registerForActivityResult( ActivityResultContracts.StartActivityForResult() ) { if (Environment.isExternalStorageManager()) { startActivity() } } actionManageAppAllFilesAccessPermission.launch( Intent(Settings.ACTION_MANAGE_ALL_FILES_ACCESS_PERMISSION) ) return false } } else if (Build.VERSION.SDK_INT \u003e= Build.VERSION_CODES.M) { if ( checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED || checkSelfPermission(Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED ) { requestPermissions(arrayOf( Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.READ_EXTERNAL_STORAGE ), requestRuntimePermission) return false } } return true } 안드로이드 11 권한 요청 화면\r안드로이드 11 실행 화면\r이렇게 다시 파일 접근이 가능해 진다. 하지만 MANAGE_EXTERNAL_STORAGE 권한을 가진 앱을 플레이스토어에 배포하려면 구글에서는 특별한 목적(파일관리, 암호화 등)이 있는 앱인지를 심사한다고 한다. 만약 전체 스토리지에 접근하는 것이 아닌 단순히 파일에 접근하는 경우 저장소 액세스 프레임워크 혹은 Media Store API를 이용하면 된다고 한다. 하지만 취미로 만들면서 그냥 맘 편하게 이용하고 있기 때문에 추후에 필요하다면 이에 대해 정리해 보려고 한다. ","date":"2022-10-31","objectID":"/2022/10/2022-10-31-%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%A0%91%EA%B7%BC/:4:0","tags":["Android","Storage","Permission"],"title":"안드로이드 스토리지 접근","uri":"/2022/10/2022-10-31-%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%A0%91%EA%B7%BC/"},{"categories":["Android"],"content":"정리 예전 안드로이드가 처음 나왔을 때 이런저런 앱을 만들었었지만 그 후에는 안드로이드 앱 개발과는 거리가 먼 생활을 하다가 오랜만에 만들어 보고 싶은 것이 있어 찾아본 내용들을 정리해 보았다. ","date":"2022-10-31","objectID":"/2022/10/2022-10-31-%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%A0%91%EA%B7%BC/:5:0","tags":["Android","Storage","Permission"],"title":"안드로이드 스토리지 접근","uri":"/2022/10/2022-10-31-%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%A0%91%EA%B7%BC/"},{"categories":["Android"],"content":"최종 코드 \u003c!-- AndroidMenifest.xml --\u003e \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cmanifest xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\"\u003e \u003cuses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/\u003e \u003cuses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/\u003e \u003cuses-permission android:name=\"android.permission.MANAGE_EXTERNAL_STORAGE\" tools:ignore=\"ScopedStorage\" /\u003e \u003capplication android:allowBackup=\"true\" android:dataExtractionRules=\"@xml/data_extraction_rules\" android:fullBackupContent=\"@xml/backup_rules\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:roundIcon=\"@mipmap/ic_launcher_round\" android:requestLegacyExternalStorage=\"true\" android:supportsRtl=\"true\" android:theme=\"@style/Theme.StorageTest\" tools:targetApi=\"31\"\u003e \u003cactivity android:name=\".MainActivity\" android:exported=\"true\"\u003e \u003cintent-filter\u003e \u003caction android:name=\"android.intent.action.MAIN\" /\u003e \u003ccategory android:name=\"android.intent.category.LAUNCHER\" /\u003e \u003c/intent-filter\u003e \u003cmeta-data android:name=\"android.app.lib_name\" android:value=\"\" /\u003e \u003c/activity\u003e \u003c/application\u003e \u003c/manifest\u003e // MainActivity.kt class MainActivity : AppCompatActivity() { companion object { const val requestRuntimePermission = 1 } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) if (requestRuntimePermission()) { startActivity() } } fun requestRuntimePermission(): Boolean { if (Build.VERSION.SDK_INT \u003e= Build.VERSION_CODES.R) { if (!Environment.isExternalStorageManager()) { val actionManageAppAllFilesAccessPermission = registerForActivityResult( ActivityResultContracts.StartActivityForResult() ) { if (Environment.isExternalStorageManager()) { startActivity() } } actionManageAppAllFilesAccessPermission.launch( Intent(Settings.ACTION_MANAGE_ALL_FILES_ACCESS_PERMISSION) ) return false } } else if (Build.VERSION.SDK_INT \u003e= Build.VERSION_CODES.M) { if ( checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED || checkSelfPermission(Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED ) { requestPermissions(arrayOf( Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.READ_EXTERNAL_STORAGE ), requestRuntimePermission) return false } } return true } override fun onRequestPermissionsResult( requestCode: Int, permissions: Array\u003cout String\u003e, grantResults: IntArray ) { when(requestCode) { requestRuntimePermission -\u003e { if (grantResults.any { it != 0 }) { // 획득에 실패한 권한이 있으면 메세지 출력 후 종료 Toast.makeText(this, \"권한 획득 실패\", Toast.LENGTH_LONG).show() finish() } else { Toast.makeText(this, \"권한 획득 성공\", Toast.LENGTH_LONG).show() startActivity() } } else -\u003e {} } super.onRequestPermissionsResult(requestCode, permissions, grantResults) } fun showToast() { File(\"${getSdPath()}/test.txt\").inputStream().use { Toast.makeText(this, String(it.readBytes()), Toast.LENGTH_LONG).show() } } fun writeFile() { File(\"${getSdPath()}/test.txt\").outputStream().use { it.write(\"test ver: ${getAndroidVersion()}\".toByteArray()) } } fun getSdPath() = if (Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) { Environment.getExternalStorageDirectory().absolutePath } else { Environment.MEDIA_UNMOUNTED } fun startActivity() { writeFile() showToast() } private fun getAndroidVersion(): String { val builder = StringBuilder() builder.append(\"android : \").append(Build.VERSION.RELEASE) val fields: Array\u003cField\u003e = Build.VERSION_CODES::class.java.fields for (field in fields) { val fieldName: String = field.name var fieldValue = -1 try { fieldValue = field.getInt(Any()) } catch (e: IllegalArgumentException) { e.printStackTrace() } catch (e: IllegalAccessException) { e.printStackTrace() } catch (e: NullPointerException) { e.printStackTrace() } if (fieldValue == Build.VERSION.SDK_INT) { builder.append(\" : \").append(fieldName).append(\" : \") builder.append(\"sdk=\").append(fieldValue) } } re","date":"2022-10-31","objectID":"/2022/10/2022-10-31-%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%A0%91%EA%B7%BC/:6:0","tags":["Android","Storage","Permission"],"title":"안드로이드 스토리지 접근","uri":"/2022/10/2022-10-31-%EC%95%88%EB%93%9C%EB%A1%9C%EC%9D%B4%EB%93%9C-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%A0%91%EA%B7%BC/"},{"categories":["Guide"],"content":"설치방법 윈도우의 경우 관리자권한으로 powershell 혹은 cmd에서 아래 명령어를 이용하여 설치한다 \u003e choco install hugo -confirm \u003e choco install hugo-extended -confirm 맥의 경우에는 brew를 이용하여 설치 $ brew install hugo 리눅스의 경우는 각 배포판에 맞는 패키지 관리자를 이용하여 설치 ","date":"2022-10-30","objectID":"/2022/10/2022-10-31-hugo-%EC%84%A4%EC%B9%98-with-github-io/:1:0","tags":["Hugo","Blog"],"title":"Hugo 설치 (with. github.io)","uri":"/2022/10/2022-10-31-hugo-%EC%84%A4%EC%B9%98-with-github-io/"},{"categories":["Guide"],"content":"Hugo 블로그 생성 + github 설정 우선 레포를 두개 사용하는 방식으로 하였다. \u003cgithub id\u003e.github.io: 실제 웹에 노출되는 레포 (무조건 public) blog: hugo 원본 파일들을 올리는 레포 (private 도 상관없음) \u003e hugo new site \u003cblog 이름\u003e \u003e cd \u003cblog 이름\u003e \u003e git init \u003e git submodule \u003c테마 repo\u003e themes/\u003c테마이름\u003e \u003e rm public \u003e git submodule \u003cgithub io 레포\u003e public 각자 정한 테마에 맞는 config.toml 를 작성하여 준다 (이 블로그는 Loveit 테마를 사용하였다) deploy 를 편하게하기 위한 스크립트 $DATETIME = get-date -format yyyyMMdd_HHmmss $COMMIT_MSG=\"publish $DATETIME\" echo $COMMIT_MSG hugo -t \u003ctheme\u003e cd public git add . git commit -m $COMMIT_MSG git push origin main cd .. git add . git commit -m $COMMIT_MSG git push origin main ","date":"2022-10-30","objectID":"/2022/10/2022-10-31-hugo-%EC%84%A4%EC%B9%98-with-github-io/:2:0","tags":["Hugo","Blog"],"title":"Hugo 설치 (with. github.io)","uri":"/2022/10/2022-10-31-hugo-%EC%84%A4%EC%B9%98-with-github-io/"},{"categories":["Guide"],"content":"giscus 설정 giscus.app를 참조하여 댓글이 저장될 레포에 설정하여준다. 위 페이지에서 모든 정보를 입력해주고 나오는 정보를 기반으로 loveit 테마의 설정파일에 정보를 입력하여 준다. [params.page.comment.giscus] enable = true repo = \"\" repoId = \"\" category = \"\" categoryId = \"\" lang = \"ko\" mapping = \"pathname\" reactionsEnabled = \"1\" emitMetadata = \"0\" inputPosition = \"bottom\" lazyLoading = true lightTheme = \"light\" darkTheme = \"dark\" 만약 테마에서 설정파일을 지원하지 않는다면 설치한 테마의 comment.html 파일에 위 giscus페이지에서 생성해준 script 코드를 붙여넣으면 된다. ","date":"2022-10-30","objectID":"/2022/10/2022-10-31-hugo-%EC%84%A4%EC%B9%98-with-github-io/:3:0","tags":["Hugo","Blog"],"title":"Hugo 설치 (with. github.io)","uri":"/2022/10/2022-10-31-hugo-%EC%84%A4%EC%B9%98-with-github-io/"},{"categories":["Guide"],"content":"CMS Plugin 이 글을 작성하면서 스크린샷이나 여타 다른 기능들을 편하게 사용하기 위해 사용해보는 플러그인인데 사용하기 괜찮은것 같다. FRONT MATTER ","date":"2022-10-30","objectID":"/2022/10/2022-10-31-hugo-%EC%84%A4%EC%B9%98-with-github-io/:4:0","tags":["Hugo","Blog"],"title":"Hugo 설치 (with. github.io)","uri":"/2022/10/2022-10-31-hugo-%EC%84%A4%EC%B9%98-with-github-io/"}]